<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 木然轩</title><link>https://muranxuan.top/tags/java/</link><description>Recent content in Java on 木然轩</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 24 Oct 2021 21:05:55 +0800</lastBuildDate><atom:link href="https://muranxuan.top/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>基于Netty实现简单的Redis服务端</title><link>https://muranxuan.top/p/8mkz5/</link><pubDate>Sun, 24 Oct 2021 21:05:55 +0800</pubDate><guid>https://muranxuan.top/p/8mkz5/</guid><description>前言 在上一篇的基于Netty实现简单的Redis客户端 - 木然轩 - 文剑木然的网络日志中我介绍了如何使用Netty来编写一个简单的Redis客户</description></item><item><title>基于Netty实现简单的Redis客户端</title><link>https://muranxuan.top/p/8mkvr/</link><pubDate>Sun, 24 Oct 2021 19:03:28 +0800</pubDate><guid>https://muranxuan.top/p/8mkvr/</guid><description>前言 Netty是Java中非常常用的网络库，它能自定义网络通信协议，从而实现非常丰富多样的网络功能。Redis是开发中非常常用的中间件，常用</description></item><item><title>《Netty实战》读书笔记——Netty的概念及体系结构</title><link>https://muranxuan.top/p/8md9t/</link><pubDate>Sun, 17 Oct 2021 22:41:41 +0800</pubDate><guid>https://muranxuan.top/p/8md9t/</guid><description>Netty 的核心组件 Channel 可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调 一个回调其实就是一个</description></item><item><title>《Java NIO系列教程》学习笔记</title><link>https://muranxuan.top/p/8ikmq/</link><pubDate>Wed, 16 Jun 2021 23:14:54 +0800</pubDate><guid>https://muranxuan.top/p/8ikmq/</guid><description>Java NIO 由以下几个核心部分组成： Channels Buffers Selectors Channel FileChannel：从文件中读写数据 DatagramChannel：能通过UDP读写网络中的数据 So</description></item><item><title>LockSupport源码分析</title><link>https://muranxuan.top/p/8dxvk/</link><pubDate>Sun, 17 Jan 2021 21:20:19 +0800</pubDate><guid>https://muranxuan.top/p/8dxvk/</guid><description>LockSupport简介 LockSupport可以控制线程的状态，从而达到线程在等待唤醒之间切换的目的，并且不用担心阻塞和唤醒操作的顺序，</description></item><item><title>ClassNotFoundException与NoClassDefFoundError【译】</title><link>https://muranxuan.top/p/7zc5g/</link><pubDate>Wed, 02 Oct 2019 17:40:00 +0800</pubDate><guid>https://muranxuan.top/p/7zc5g/</guid><description>ClassNotFoundException 和 NoClassDefFoundError 都是某个类在运行时没有找到时出现的，但它们发生的场景不同。 ClassNotFoundException 是一个异常，当你在运行时使用 Class.forName() 或 loadClass() 方法尝试去加载一个类且这个类没有在 classpath 下找</description></item><item><title>深入理解Java序列化</title><link>https://muranxuan.top/p/7z5ti/</link><pubDate>Fri, 27 Sep 2019 00:54:00 +0800</pubDate><guid>https://muranxuan.top/p/7z5ti/</guid><description>所谓序列化，就是将对象转为字节流，而反序列化则是将字节流还原为对象。 序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中，在网络上</description></item><item><title>HashMap源码分析</title><link>https://muranxuan.top/p/7z5ke/</link><pubDate>Thu, 26 Sep 2019 19:26:00 +0800</pubDate><guid>https://muranxuan.top/p/7z5ke/</guid><description>HashMap是很重要的数据结构，也是面试的宠儿，这里就HashMap的源码进行分析，以便理解HashMap的实现。 散列表 散列表（Hash t</description></item><item><title>深入理解JAVA虚拟机——垃圾回收</title><link>https://muranxuan.top/p/7uzkg/</link><pubDate>Tue, 14 May 2019 19:28:00 +0800</pubDate><guid>https://muranxuan.top/p/7uzkg/</guid><description>Survivor的作用 当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随</description></item><item><title>牛客网中级项目第二次课</title><link>https://muranxuan.top/p/7uyk9/</link><pubDate>Mon, 13 May 2019 21:45:00 +0800</pubDate><guid>https://muranxuan.top/p/7uyk9/</guid><description>SpringBoot工程 建立初始SpringBoot工程的两种方式： 1、https://start.spring.io/ 2、使用Intell</description></item><item><title>《实战Java高并发程序设计》读书笔记</title><link>https://muranxuan.top/p/7t3gc/</link><pubDate>Thu, 14 Mar 2019 12:12:00 +0800</pubDate><guid>https://muranxuan.top/p/7t3gc/</guid><description>这两天快速看了下《实战Java高并发程序设计》这本书，对Java高并发程序有一个初步的认识。 这本书是在iPad上用MarginNotes 3看</description></item></channel></rss>