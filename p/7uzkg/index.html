<!doctype html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="IE=edge,chrome=1"><title>深入理解JAVA虚拟机——垃圾回收 - 木然轩</title><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="cache-control" content="no-transform"><meta http-equiv="cache-control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="author" content="木然猫猫"><meta name="description" content="Survivor的作用 当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随"><meta name="keywords" content="木然猫猫,木然轩,计算机"><meta name="generator" content="Hugo 0.101.0 with theme even"><link rel="canonical" href="https://muranxuan.top/p/7uzkg/"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet"><link crossorigin="anonymous" integrity="sha384-PIbA/zVJy6+10NGzgoUJuAtvdc4oBIixlc+vhWHFc4qCJB32bWRvGzPA6YQhEWwx" href="https://lib.baomitu.com/fancybox/3.1.20/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/custom.css"><meta property="og:title" content="深入理解JAVA虚拟机——垃圾回收"><meta property="og:description" content="Survivor的作用 当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随"><meta property="og:type" content="article"><meta property="og:url" content="https://muranxuan.top/p/7uzkg/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-05-14T19:28:00+08:00"><meta property="article:modified_time" content="2019-05-14T19:28:00+08:00"><meta itemprop="name" content="深入理解JAVA虚拟机——垃圾回收"><meta itemprop="description" content="Survivor的作用 当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随"><meta itemprop="datePublished" content="2019-05-14T19:28:00+08:00"><meta itemprop="dateModified" content="2019-05-14T19:28:00+08:00"><meta itemprop="wordCount" content="2383"><meta itemprop="keywords" content="Java,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入理解JAVA虚拟机——垃圾回收"><meta name="twitter:description" content="Survivor的作用 当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随"><!--[if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script><![endif]--><!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script><![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">木然轩</a></div><div class="mobile-navbar-icon"><span></span>
<span></span>
<span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">主页</li></a><a href="/post/"><li class="mobile-menu-item">归档</li></a><a href="/tags/"><li class="mobile-menu-item">标签</li></a><a href="/about/"><li class="mobile-menu-item">关于</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"><a href="/" class="logo">木然轩</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">主页</a></li><li class="menu-item"><a class="menu-item-link" href="/post/">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/tags/">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/about/">关于</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">深入理解JAVA虚拟机——垃圾回收</h1><div class="post-meta"><span class="post-time">2019-05-14</span>
<span class="more-meta">约 2383 字</span>
<span class="more-meta">预计阅读 5 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#survivor的作用">Survivor的作用</a></li><li><a href="#为什么要两个survivor">为什么要两个Survivor</a></li><li><a href="#新生代空间优化">新生代空间优化</a></li><li><a href="#动态年龄计算">动态年龄计算</a></li><li><a href="#并发预清理">并发预清理</a></li><li><a href="#卡表">卡表</a></li><li><a href="#参考文献">参考文献</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="survivor的作用">Survivor的作用</h2><p>当没有Survivor时，如果增加老年代空间，需要更多存活对象才能填满老年代，这样可以降低Full GC的频率；但是，随着老年代空间加大，一旦发生Full GC，执行所需要的时间更长。</p><p>如果减少老年代空间，虽然Full GC所需时间减少；但是，老年代很快被存活对象填满，Full GC频率增加。</p><p>因此，Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生。</p><h2 id="为什么要两个survivor">为什么要两个Survivor</h2><p>解释一：为了解决碎片化。如果只有一个Survivor，对象在Eden创建，GC时存活对象复制到Survivor，当下次GC时，没有一个空闲的Survivor，而Survivor中也会有可回收对象，这样在Survivor中就出现了大量的空闲碎片。如果有两个Survivor，每次GC将Eden和其中一个Survivor中的存活对象复制到另一个Survivor，前一个Survivor会因此空闲，于是下次GC可以重复这样的过程，从而解决了碎片化。</p><p>解释二：复制算法将内存等分为两块，每次只使用其中一块，GC时将存活对象移至另一块，前一块因此空闲。引入Eden可以视为对内存利用的优化，相当于两个Survivor共享的区域，每次GC后Eden都会因此空闲，这样相当于扩大了Survivor，避免频繁GC。</p><h2 id="新生代空间优化">新生代空间优化</h2><p>通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。扩容新生代后，Minor GC的时间未必会显著增加。这是因为虽然扩容新生代会增加扫描时间，但一些对象会变成可回收，从而省去了一部分复制对象的时间。</p><p>对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。</p><p>如何选择各分区大小应该依赖应用程序中对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</p><h2 id="动态年龄计算">动态年龄计算</h2><p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。</p><p>JVM引入动态年龄计算，主要基于如下两点考虑：</p><p>1、如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：</p><ul><li>a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。</li><li>b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</li></ul><p>2、相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</p><p>总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p><h2 id="并发预清理">并发预清理</h2><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/7uzkg/e78dea7d7fd801c7e30aac3786ac2c4c022e6b6d.png" alt></p><p>新生代中存在对老年代对象的引用，或者老年代中存在对新生代的引用，称为<strong>跨代引用</strong>。</p><p>由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆。为了避免扫描时新生代有很多对象，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活。CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime，含义是如果可中断的预清理执行超时，不管发没发生Minor GC，都会中止此阶段，进入Remark。如果超时等不到Minor GC，Remark时新生代仍然有很多对象。CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC，从而降低Remark阶段的时间。</p><h2 id="卡表">卡表</h2><p>老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p><p>经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/7uzkg/69c0398892d1b20fd08c584f60bd079b555438c4.png" alt></p><p>卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p><p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p><p>卡表具有“滞后性”，浪费一定的空间；如下图所示，Minor GC时实际上对象E可以被回收，但是由于没发生Full GC，老年代中的对象D仍存在对对象E的引用，导致E无法被回收。</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/7uzkg/ebc1d435ce785381f93f1604ce490e4e2358f85a.png" alt></p><h2 id="参考文献">参考文献</h2><ul><li><p><a href="https://stackoverflow.com/questions/10695298/java-gc-why-two-survivor-regions">garbage collection - Java GC: why two survivor regions? - Stack Overflow</a></p></li><li><p>周志明《深入理解Java虚拟机》</p></li><li><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化 - 美团技术团队</a></p></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/">Java</a></div><nav class="post-nav"><a class="prev" href="/p/7v45r/"><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">使用fail2ban防范Linux服务器SSH暴力登录尝试攻击</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class="next" href="/p/7uyk9/"><span class="next-text nav-default">牛客网中级项目第二次课</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src="https://utteranc.es/client.js" repo="straicat/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:1121672253@qq.com" class="iconfont icon-email" title="email"></a>
<a href="https://github.com/straicat" class="iconfont icon-github" title="github"></a>
<a href="https://www.zhihu.com/people/wjmr" class="iconfont icon-zhihu" title="zhihu"></a>
<a href="https://space.bilibili.com/4583328" class="iconfont icon-bilibili" title="bilibili"></a>
<a href="https://muranxuan.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动</span>
<span class="division">|</span>
<span class="theme-info">主题 -
<a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a></span>
<span class="copyright-year">&copy;
2015 -
2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>木然猫猫</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script crossorigin="anonymous" integrity="sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f" src="https://lib.baomitu.com/jquery/3.2.1/jquery.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-wEpzWQjx2cAZH0dWbs0yERz/XdefbIlX5blnSszkdz74KNvkYtwawfCkfmoNgkgu" src="https://lib.baomitu.com/slideout/1.0.1/slideout.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-/KW95nVynfwuFdnC4bvJaEQl1ofFOKDm2+IMq+KXhojg4YXyJ/8Fa50AtFMy9POi" src="https://lib.baomitu.com/fancybox/3.1.20/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
<script id="baidu_analytics">var _hmt=_hmt||[];(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.async=!0,e.src="https://hm.baidu.com/hm.js?c7fb717ef5f3ae5fea89edf439acd013",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script src="/js/custom.js"></script></body></html>