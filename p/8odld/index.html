<!doctype html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="IE=edge,chrome=1"><title>Wireshark数据包分析实战学习笔记一 - 木然轩</title><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="cache-control" content="no-transform"><meta http-equiv="cache-control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="author" content="木然猫猫"><meta name="description" content="捕获过滤器的BPF语法 使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。每个原语包含一个或多个限定词，然后跟着一个I"><meta name="keywords" content="木然猫猫,木然轩,计算机"><meta name="generator" content="Hugo 0.101.0 with theme even"><link rel="canonical" href="https://muranxuan.top/p/8odld/"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet"><link crossorigin="anonymous" integrity="sha384-PIbA/zVJy6+10NGzgoUJuAtvdc4oBIixlc+vhWHFc4qCJB32bWRvGzPA6YQhEWwx" href="https://lib.baomitu.com/fancybox/3.1.20/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/custom-ed977ed4.css"><meta property="og:title" content="Wireshark数据包分析实战学习笔记一"><meta property="og:description" content="捕获过滤器的BPF语法 使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。每个原语包含一个或多个限定词，然后跟着一个I"><meta property="og:type" content="article"><meta property="og:url" content="https://muranxuan.top/p/8odld/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-12-22T00:49:57+08:00"><meta property="article:modified_time" content="2021-12-22T00:49:57+08:00"><meta itemprop="name" content="Wireshark数据包分析实战学习笔记一"><meta itemprop="description" content="捕获过滤器的BPF语法 使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。每个原语包含一个或多个限定词，然后跟着一个I"><meta itemprop="datePublished" content="2021-12-22T00:49:57+08:00"><meta itemprop="dateModified" content="2021-12-22T00:49:57+08:00"><meta itemprop="wordCount" content="4573"><meta itemprop="keywords" content><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Wireshark数据包分析实战学习笔记一"><meta name="twitter:description" content="捕获过滤器的BPF语法 使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。每个原语包含一个或多个限定词，然后跟着一个I"><!--[if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script><![endif]--><!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script><![endif]--><meta property="editUrl" content="https://github.com/straicat/muranxuan.top/edit/master/content/post/2021/2021-12-22-Wireshark数据包分析实战学习笔记一.md"></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">木然轩</a></div><div class="mobile-navbar-icon"><span></span>
<span></span>
<span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">主页</li></a><a href="/post/"><li class="mobile-menu-item">归档</li></a><a href="/tags/"><li class="mobile-menu-item">标签</li></a><a href="/about/"><li class="mobile-menu-item">关于</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"><a href="/" class="logo">木然轩</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">主页</a></li><li class="menu-item"><a class="menu-item-link" href="/post/">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/tags/">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/about/">关于</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">Wireshark数据包分析实战学习笔记一</h1><div class="post-meta"><span class="post-time">2021-12-22</span>
<span class="more-meta">约 4573 字</span>
<span class="more-meta">预计阅读 10 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#捕获过滤器的bpf语法">捕获过滤器的BPF语法</a><ul><li><a href="#主机名和地址过滤器">主机名和地址过滤器</a></li></ul></li><li><a href="#显示过滤器">显示过滤器</a></li><li><a href="#wireshark高级特性">Wireshark高级特性</a><ul><li><a href="#统计窗口">统计窗口</a></li><li><a href="#名字解析">名字解析</a></li><li><a href="#数据包长度">数据包长度</a></li><li><a href="#协议解析">协议解析</a></li><li><a href="#跟踪tcp流">跟踪TCP流</a></li><li><a href="#图形展示">图形展示</a></li><li><a href="#专家信息">专家信息</a></li></ul></li><li><a href="#地址解析协议arp">地址解析协议ARP</a></li><li><a href="#ip协议">IP协议</a><ul><li><a href="#ipv4头">IPv4头</a></li><li><a href="#ip分片">IP分片</a></li></ul></li><li><a href="#传输控制协议tcp">传输控制协议TCP</a><ul><li><a href="#三次握手">三次握手</a></li><li><a href="#四次挥手">四次挥手</a></li><li><a href="#tcp重置">TCP重置</a></li></ul></li><li><a href="#用户数据包协议udp">用户数据包协议UDP</a></li><li><a href="#互联网控制消息协议icmp">互联网控制消息协议ICMP</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="捕获过滤器的bpf语法">捕获过滤器的BPF语法</h2><p>使用BPF语法创建的过滤器被称为表达式，并且每个表达式包含一个或多个原语。每个原语包含一个或多个限定词，然后跟着一个ID名字或数字</p><table><thead><tr><th>限定词</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>类型限定词</td><td>指出名字或数字所代表的意义</td><td>host、net、host</td></tr><tr><td>传输方向限定词</td><td>指明传输方向是前往还是来自名字或数字</td><td>src、dst</td></tr><tr><td>协议限定词</td><td>限定所要匹配的协议</td><td>ether、ip、tcp、udp、http、ftp</td></tr></tbody></table><p>可以使用以下3种逻辑运算符，对原语进行组合，从而创建更高级的表达式</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/f55a60215ef89c7bcdea8f26fafa720d3c28c685.png" alt="捕获过滤器语法.drawio"></p><ul><li>连接运算符 与（&&）</li><li>选择运算符 或（||）</li><li>否定运算符 非（!）</li></ul><p>例如，源地址是192.168.0.10 并且 源或目标端口是80：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">src 192.168.0.10 &amp;&amp; port 80
</span></span></code></pre></td></tr></table></div></div><p><code>Type</code>：设置数字或者名称所指的类型，例如<code>host www.baidu.com</code></p><ul><li><code>host</code>、<code>port</code></li><li><code>net</code>，设定子网，如 <code>net 192.168.0.0 mask 255.255.255.0</code> 等价于 <code>net 192.168.0.0/24</code></li><li><code>portrange</code>，设置端口范围，例如 <code>portrange 6000-8000</code></li></ul><p><code>Dir</code>：设置网络出入方向，例如 <code>dst port 80</code></p><ul><li><code>src</code>、<code>dst</code>、<code>src</code>、<code>src or dst</code>、<code>src and dst</code>（<code>src</code> 表示源，<code>dst</code> 表示目标）</li><li><code>ra</code>、<code>ta</code>、<code>addr1</code>、<code>addr2</code>、<code>addr3</code>、<code>addr4</code>、（仅对 <code>IEEE 802.11 Wireless LAN</code>有效）</li></ul><p><code>Proto</code>：指定协议类型，例如 <code>udp</code></p><ul><li><code>ether</code>、<code>fddi</code>、<code>tr</code>、<code>wlan</code>、<code>ip</code>、<code>ip6</code>、<code>arp</code>、<code>rarp</code>、<code>decnet</code>、<code>tcp</code>、<code>udp</code>、<code>icmp</code>、<code>igmp</code>、<code>icmp</code>、<code>igrp</code>、<code>pim</code>、<code>ah</code>、<code>esp</code>、<code>vrrp</code></li></ul><p>其他</p><ul><li><code>geteway</code>：指明网关 <code>IP</code> 地址，等价于 <code>ether host $ehost and not host $host</code></li><li><code>broadcast</code>：广播报文，例如<code>ether broadcast</code> 或者 <code>ip broadcast</code></li><li><code>multicast</code>：多播报文，例如 <code>ip multicast</code> 或者 <code>ip6 multicast</code></li><li><code>less</code>，<code>greater</code>小于或者大于</li></ul><h3 id="主机名和地址过滤器">主机名和地址过滤器</h3><p>可以根据设备的MAC地址、ipv4地址、ipv6地址或者DNS主机名配置过滤规则</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 根据IPv4地址过滤</span>
</span></span><span class="line"><span class="cl">host 172.16.16.149
</span></span><span class="line"><span class="cl"><span class="c1"># 根据IPv6地址过滤</span>
</span></span><span class="line"><span class="cl">host 2001:db8:85a3:8a2e:370:7334
</span></span><span class="line"><span class="cl"><span class="c1"># 根据主机名过滤</span>
</span></span><span class="line"><span class="cl">host testserver2
</span></span><span class="line"><span class="cl"><span class="c1"># 根据MAC地址过滤</span>
</span></span><span class="line"><span class="cl">ether host 00-1a-a0-52-e2-a0
</span></span></code></pre></td></tr></table></div></div><p>传输方向限定词用来捕获流向或流出某台主机的流量</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 捕获来自某台主机的流量</span>
</span></span><span class="line"><span class="cl">src host 172.16.16.149
</span></span><span class="line"><span class="cl"><span class="c1"># 捕获流出某台主机的流量</span>
</span></span><span class="line"><span class="cl">dst host 172.16.16.149
</span></span><span class="line"><span class="cl"><span class="c1"># 没有类型限定符时默认为host</span>
</span></span><span class="line"><span class="cl">dst 173.16.16.149
</span></span></code></pre></td></tr></table></div></div><p>端口和协议过滤器可以对基于每个数据包的端口进行过滤，端口过滤通常被用来过滤使用已知端口的服务和应用。端口过滤器可以和传输方向限定词一起使用</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 捕获8080端口的流量</span>
</span></span><span class="line"><span class="cl">port <span class="m">8080</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 捕获8080端口外的流量</span>
</span></span><span class="line"><span class="cl">!port <span class="m">8080</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 只捕获前往监听标准HTTP 80端口的Web服务器的流量</span>
</span></span><span class="line"><span class="cl">dst port <span class="m">80</span>
</span></span></code></pre></td></tr></table></div></div><p>协议过滤器协议过滤器可以基于特定协议进行数据包过滤，这通常被用于那些不是应用层的不能简单地使用特定端口进行定义的协议</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 捕获ICMP流量</span>
</span></span><span class="line"><span class="cl">icmp
</span></span><span class="line"><span class="cl"><span class="c1"># 捕获除了ipv6之外的所有流量</span>
</span></span><span class="line"><span class="cl">!ip6
</span></span></code></pre></td></tr></table></div></div><p>协议域过滤器可以通过检查协议头中的每一个字节来创建基于那些数据的特殊过滤器</p><p><code>&</code> 指定在字节中检查的比特位置</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 字节偏移量为0的位置为3的ICMP数据包</span>
</span></span><span class="line"><span class="cl">icmp<span class="o">[</span>0<span class="o">]==</span><span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 检查代表echo请求（类型8）或echo回复（类型0）的ICMP数据包</span>
</span></span><span class="line"><span class="cl">icmp<span class="o">[</span>0<span class="o">]==</span>8<span class="o">||</span>icmp<span class="o">[</span>0<span class="o">]==</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 检查数据包头部偏移了为0处的2个字节的ICMP过滤器，并与十六进制0301进行比较</span>
</span></span><span class="line"><span class="cl">icmp<span class="o">[</span>0:2<span class="o">]==</span>0x0301
</span></span><span class="line"><span class="cl"><span class="c1"># 只捕获带有RST标志的TCP数据包</span>
</span></span><span class="line"><span class="cl">tcp<span class="o">[</span>13<span class="o">]</span><span class="p">&amp;</span><span class="nv">4</span><span class="o">==</span><span class="m">4</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 只捕获带有PSH标志的TCP数据包</span>
</span></span><span class="line"><span class="cl">tcp<span class="o">[</span>13<span class="o">]</span><span class="p">&amp;</span><span class="nv">8</span><span class="o">==</span><span class="m">8</span>
</span></span></code></pre></td></tr></table></div></div><p>抓取 HTTP GET 报文：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420
</span></span></code></pre></td></tr></table></div></div><p>注意 47455420 是 ASCII 码的 16 进制，表示 &lsquo;GET&rsquo;，TCP 报文头可能不只 20 字节，data offset 提示了承载数据的偏移，但它以 4 字节为单位</p><h2 id="显示过滤器">显示过滤器</h2><p>比较操作符：==，!=，>，&lt;，>=，&lt;=</p><p>逻辑操作符：and，or，xor（有且仅有一个条件被满足），not</p><table><thead><tr><th>过滤器</th><th>说明</th></tr></thead><tbody><tr><td>tcp.port==3389</td><td>排除RDP流量</td></tr><tr><td>tcp.flags.syn==1</td><td>具有SYN标志位的TCP数据包</td></tr><tr><td>tcp.flags.rst==1</td><td>具有RST标志位的TCP数据包</td></tr><tr><td>!arp</td><td>排除ARP流量</td></tr><tr><td>http</td><td>所有HTTP流量</td></tr><tr><td>tcp.port==23 || tcp.port==21</td><td>文本管理流量（Telnet或FTP）</td></tr><tr><td>smtp || pop || imap</td><td>文本email流量（SMTP、POP或IMAP）</td></tr></tbody></table><h2 id="wireshark高级特性">Wireshark高级特性</h2><h3 id="统计窗口">统计窗口</h3><p>Endpoint统计窗口（统计->Endpoints）给出了每一端点的许多有用的统计数据</p><p>会话统计窗口（统计->Conversations）显示了会话中端点的地址，以及每个设备发送或受到的数据包和字节数</p><p>协议分级统计窗口（统计->协议分级）查看正在使用协议的分布情况，提供一个网络中活动类型的直观快照，来得到网络中用户和设备的情况</p><h3 id="名字解析">名字解析</h3><p>MAC地址解析：使用ARP协议将MAC地址转为IP地址，兜底策略为转换到设备IEEE指定制造商名称</p><p>网络名称解析：将IP地址解析为易读的主机名称</p><p>传输名称解析：将端口号转为一个与之相关的名字，如80端口显示为HTTP</p><h3 id="数据包长度">数据包长度</h3><p>统计->分组长度</p><p>较大的数据包通常是用于数据，而较小的数据包则一般是协议控制序列。</p><h3 id="协议解析">协议解析</h3><p>更换解析器：右键，Decode As，在“当前”里修改解析器</p><p>解析器源码：<a href="https://gitlab.com/wireshark/wireshark/-/tree/master/epan/dissectors">epan/dissectors · master · Wireshark Foundation / wireshark · GitLab</a> 名称为：packet-协议名.c</p><h3 id="跟踪tcp流">跟踪TCP流</h3><p>Wireshark能将流重组成容易阅读的格式，可以将从客户端发往服务器的数据排好顺序使之容易查看，而不需要一小块一小块地看。这在查看HTTP、FTP等纯文本应用层协议时非常好用</p><p>右键，跟踪流，TCP流，这时TCP流就会在一个单独的窗口中显示出来。红色标明从源地址前往目标地址的流量，蓝色用来区分相反方向，颜色标记以哪方先开始通信为准。</p><h3 id="图形展示">图形展示</h3><p>查看IO图（统计->I/O Graphs）：可以对网络上的吞吐量进行绘图，显示捕获过程中每个周期的数据包的数量</p><p>双向时间图（统计->TCP流图形->往返时间）：数据包已被成功接收所需的时间，每个点都代表了一个数据包的双向时间，默认按序列号排序。</p><p>数据流图（统计->流量图）：数据流绘图功能对于将连接可视化，以及将一段时间中的数据流显示出来非常有用。数据流图一般以列的方式将主机之间的连接显示出来，并将数据流组织到一起，以便更直观地解读。</p><h3 id="专家信息">专家信息</h3><p>分析->专家信息：可以得到使用这个协议的数据包中一些特定状态的信息。分为4类：</p><ul><li>对话信息：窗口更新</li><li>注意信息：TCP重传输、重复ACK、零窗口探查、保活ACK、零窗口探查ACK、窗口已满</li><li>警告信息：上一段丢失、收到丢失数据包的ACK、保活、零窗口、乱序、快速重传输</li><li>错误信息</li></ul><h2 id="地址解析协议arp">地址解析协议ARP</h2><p>RFC：<a href="https://www.rfc-editor.org/rfc/rfc826.txt">https://www.rfc-editor.org/rfc/rfc826.txt</a></p><p>将IP地址解析为MAC地址的过程称为地址解析协议（Address Resolution Protocol，ARP）。这个协议在RFC826中进行了定义，它的解析过程只使用两种数据包：一个ARP请求与一个ARP响应</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/ccfc3d5bb888af61be96cb306b42287f69ba793f.png" alt="ARP协议.drawio"></p><p>一旦这个解析过程完成了，传输设备就会对这个设备MAC和IP对应关系的缓存进行更新，并且开始传输数据。</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/da7c9f3e0726eb41cacf9356b4377ae85faf24da.png" alt="screenshot-20211222013912"></p><ul><li>硬件类型：数据链路层使用的类型，一般是以太网（类型1）</li><li>协议类型：ARP请求正在使用的高层协议</li><li>硬件地址长度</li><li>协议地址长度</li><li>操作：ARP数据包的功能。1：请求，2：响应</li><li>发送方硬件地址</li><li>发送方协议地址</li><li>目标硬件地址。ARP请求中为0</li><li>目标协议地址</li></ul><p>ARP请求：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/6084c98aa88f0b38dd0bb36ddb6548e3867b9469.png" alt="screenshot-20211222014645"></p><p>ARP响应:</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/db100d667a5d4a9013e25d211c7c544db4199489.png" alt="screenshot-20211222014709"></p><p><strong>无偿ARP</strong></p><p>一个设备的IP地址是可以改变的，此时网络主机中缓存的IP和MAC地址映射就不再有效了。为了防止造成通信错误，无偿的ARP请求会被发送到网络中，强制所有收到它的设备去用新的IP和MAC地址映射更新缓存</p><p>无偿ARP的发送方IP地址和目标IP地址是相同的。</p><p><strong>ARP探针</strong>是一个全0 IP地址的广播请求，用来检测IPv4地址冲突。在开始使用一个IP地址之前，实现这个规范(RFC5227)的主机必须通过ARP探针测试地址是否被使用。</p><h2 id="ip协议">IP协议</h2><p>RFC791</p><h3 id="ipv4头">IPv4头</h3><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/38ee031f7c8e913c4d91db1e6a7af84170e76179.png" alt="screenshot-20211222015520"></p><ul><li>版本号：IP所使用的版本</li><li>首部长度：IP头的长度</li><li>服务类型：优先级标志位和服务类型标志位，被路由器用来进行流量的优先级排序</li><li>总长度：IP头与数据包中数据的长度</li><li>标识符：一个唯一的标识数字，用来识别一个数据包或者被分片数据包的次序</li><li>标记：用来标记一个数据包是否是一组分片数据包的一部分</li><li>分片偏移：一个数据包时一个分片，这个域中的值就会被用来将数据包以正确的顺序重新组装</li><li>存活时间：用来定义数据包的生命周期，以经过路由器的跳数/描述进行描述</li><li>协议：用来标识在数据包序列中上层协议数据包的类型</li><li>首部校验和：一个错误检测机制，用来确认IP头部的内容没有被损坏或者篡改（算的是哪一部分的？）</li><li>源IP地址</li><li>目的IP地址</li><li>选项：保留作额外的IP选项，它包含着源站路由和时间戳的一些选项</li><li>数据</li></ul><h3 id="ip分片">IP分片</h3><ol><li>设备将数据分为若干个可成功进行传输的数据包</li><li>每个IP头的总长度域会被设置为每个分片的片段长度</li><li>除了最后一个数据包，更多分片标志将会在数据流的所有数据包中设置为１</li><li>IP头中分片部分的分片偏移将会被设置。分片偏移=MTU-上一个分片的数据包的IP头长度（若无选项，则为20字节）</li><li>发送数据包</li></ol><h2 id="传输控制协议tcp">传输控制协议TCP</h2><p>RFC793</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/6dc9abebbacfc3de6b527d99f5956a51d9c927a2.png" alt="screenshot-20211222020034"></p><ul><li>源端口</li><li>目的端口</li><li>序号：用来标识一个TCP片段。这个域用来保证数据流中的部分没有缺失</li><li>确认号：通信中希望从另一个设备得到的下一个数据包的序号</li><li>标记：URG、ACK、PSH、RST、SYN、FIN标记都是用来标识所传输的TCP数据包的类型</li><li>窗口大小：TCP接收者缓冲的字节大小</li><li>校验和：用来保证TCP的头和数据的内容在抵达目的地时的完整性</li><li>紧急指针：如果设置了URG位，这个域将被检查作为额外的指令，告诉CPU从数据包的哪里开始读取数据</li><li>选项：各种可选的域，可以在TCP与数据包中进行指定</li><li>TCP的三次握手</li><li>握手过程的目的：</li><li>保证源主机确定目的主机在线，并且可以进行通信</li><li>让源主机检查它是否在监听试图去连接的端口</li><li>允许源主机向接收者发送它的初始序列号，使得两台主机可以将数据包流保持有序</li></ul><h3 id="三次握手">三次握手</h3><ol><li>A->B: SYN 序列号=x</li><li>B->A: SYN+ACK 序列号=y 确认号=x+1</li><li>A->B: ACK 序列号=x+1 确认号=y+1</li></ol><h3 id="四次挥手">四次挥手</h3><ol><li>A->Ｂ: FIN+ACK　　序列号＝x 确认号=y</li><li>B->A: ACK 序列号=y 确认号=x+1</li><li>B->A: FIN+ACK 可能：序列号=y 确认号=x+1</li><li>A->B: ACK 序列号=x+1 确认号=y+1</li></ol><h3 id="tcp重置">TCP重置</h3><p>RST标志用来指出连接被异常中止或拒绝连接请求。
RST数据包除了包含RST和ACK标志外，没有任何其他的东西，之后也并没有额外的通信。
RST数据包可以在通信序列的开始或者主机通信的过程中终止通信。</p><h2 id="用户数据包协议udp">用户数据包协议UDP</h2><p>UDP主要是为了提供高速的传输，是一种尽力服务，被称为无连接协议，并不会正式地建立和结束主机之间的连接，也没有TCP那样的握手和终止过程。</p><p>无连接协议意味着不可靠服务，这将使得UDP流量不稳定，但依赖于UDP的协议通常都会有内置的可靠性服务，或者使用ICMP的一些功能来保证连接更可靠</p><p>UDP并不关心传输的可靠性，所以任何使用UDP的应用在必要的时候都需要采取特殊的步骤，以保证可靠的传输</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/354ee2b52fa1e12f48c1695a3a3d4bfcf3d8042e.png" alt="screenshot-20211222020218"></p><ul><li>数据包长度：数据包的字节长度</li><li>校验和：用来确保UDP的头和数据到达时的完整性</li></ul><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/cb6a117a4962caf1306296958b5fc73280017538.png" alt="screenshot-20211222020239"></p><h2 id="互联网控制消息协议icmp">互联网控制消息协议ICMP</h2><p>RFC792</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8odld/f0c3007ec294ce3d6e6da3b7b0201f2e0217f510.png" alt="screenshot-20211222020500"></p><p>ICMP是IP的一部分并依赖IP来传递信息。ICMP头相对较小并根据用途而改变。</p><ul><li>类型：ICMP消息基于RFC规范的类型或分类</li><li>代码：ICMP消息基于RFC规范的子类型</li><li>校验和：用来保证ICMP头和数据在抵达目的地时的完整性</li><li>可变域：依赖于类型和代码域的部分</li></ul><p>ICMP数据包的结构取决于它由类型和代码域中的值所定义的用途</p><p>使用ping命令可以发送echo请求：echo请求和响应有着不同的Type，有着相同的序列号说明响应与请求匹配，
响应数据包中有着和请求中传输的字符串一样的内容。</p></div><footer class="post-footer"><nav class="post-nav"><a class="prev" href="/p/8w26i/"><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">基于Shamiko的隐藏Root方法</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class="next" href="/p/8n855/"><span class="next-text nav-default">《TCP IP网络编程》学习笔记一</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src="https://utteranc.es/client.js" repo="straicat/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:1121672253@qq.com" class="iconfont icon-email" title="email"></a>
<a href="https://github.com/straicat" class="iconfont icon-github" title="github"></a>
<a href="https://www.zhihu.com/people/wjmr" class="iconfont icon-zhihu" title="zhihu"></a>
<a href="https://space.bilibili.com/4583328" class="iconfont icon-bilibili" title="bilibili"></a>
<a href="https://muranxuan.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动</span>
<span class="division">|</span>
<span class="theme-info">主题 -
<a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a></span>
<span class="copyright-year">&copy;
2015 -
2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>木然猫猫</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script crossorigin="anonymous" integrity="sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f" src="https://lib.baomitu.com/jquery/3.2.1/jquery.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-wEpzWQjx2cAZH0dWbs0yERz/XdefbIlX5blnSszkdz74KNvkYtwawfCkfmoNgkgu" src="https://lib.baomitu.com/slideout/1.0.1/slideout.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-/KW95nVynfwuFdnC4bvJaEQl1ofFOKDm2+IMq+KXhojg4YXyJ/8Fa50AtFMy9POi" src="https://lib.baomitu.com/fancybox/3.1.20/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
<script id="baidu_analytics">var _hmt=_hmt||[];(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.async=!0,e.src="https://hm.baidu.com/hm.js?c7fb717ef5f3ae5fea89edf439acd013",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script src="/js/custom-2bbf1383.js"></script></body></html>