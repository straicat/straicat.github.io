<!doctype html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="IE=edge,chrome=1"><title>《Netty实战》读书笔记——Netty的概念及体系结构 - 木然轩</title><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="cache-control" content="no-transform"><meta http-equiv="cache-control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="author" content="木然猫猫"><meta name="description" content="Netty 的核心组件 Channel 可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调 一个回调其实就是一个"><meta name="keywords" content="木然猫猫,木然轩,计算机"><meta name="generator" content="Hugo 0.101.0 with theme even"><link rel="canonical" href="https://muranxuan.top/p/8md9t/"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet"><link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css" type="text/css" rel="stylesheet"><link rel="stylesheet" href="/css/custom.css"><meta property="og:title" content="《Netty实战》读书笔记——Netty的概念及体系结构"><meta property="og:description" content="Netty 的核心组件 Channel 可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调 一个回调其实就是一个"><meta property="og:type" content="article"><meta property="og:url" content="https://muranxuan.top/p/8md9t/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-10-17T22:41:41+08:00"><meta property="article:modified_time" content="2021-10-17T22:41:41+08:00"><meta itemprop="name" content="《Netty实战》读书笔记——Netty的概念及体系结构"><meta itemprop="description" content="Netty 的核心组件 Channel 可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调 一个回调其实就是一个"><meta itemprop="datePublished" content="2021-10-17T22:41:41+08:00"><meta itemprop="dateModified" content="2021-10-17T22:41:41+08:00"><meta itemprop="wordCount" content="4032"><meta itemprop="keywords" content="Java,Netty,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Netty实战》读书笔记——Netty的概念及体系结构"><meta name="twitter:description" content="Netty 的核心组件 Channel 可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调 一个回调其实就是一个"><!--[if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script><![endif]--><!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script><![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">木然轩</a></div><div class="mobile-navbar-icon"><span></span>
<span></span>
<span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">主页</li></a><a href="/post/"><li class="mobile-menu-item">归档</li></a><a href="/tags/"><li class="mobile-menu-item">标签</li></a><a href="/about/"><li class="mobile-menu-item">关于</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"><a href="/" class="logo">木然轩</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">主页</a></li><li class="menu-item"><a class="menu-item-link" href="/post/">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/tags/">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/about/">关于</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">《Netty实战》读书笔记——Netty的概念及体系结构</h1><div class="post-meta"><span class="post-time">2021-10-17</span>
<span class="more-meta">约 4032 字</span>
<span class="more-meta">预计阅读 9 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#netty-的核心组件">Netty 的核心组件</a><ul><li><a href="#channel">Channel</a></li><li><a href="#回调">回调</a></li><li><a href="#future">Future</a></li><li><a href="#事件和channel-handler">事件和Channel Handler</a></li></ul></li><li><a href="#发送消息的方式">发送消息的方式</a><ul><li><a href="#写入channel">写入Channel</a></li><li><a href="#写入channelhandlercontext">写入ChannelHandlerContext</a></li></ul></li><li><a href="#使用nio">使用NIO</a></li><li><a href="#派生缓冲区">派生缓冲区</a></li><li><a href="#channel生命周期">channel生命周期</a></li><li><a href="#channelhandler-的生命周期">ChannelHandler 的生命周期</a></li><li><a href="#出站">出站</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#eventloop">EventLoop</a><ul><li><a href="#任务调度">任务调度</a></li></ul></li><li><a href="#bootstrap">Bootstrap</a></li><li><a href="#channel实现">Channel实现</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="netty-的核心组件">Netty 的核心组件</h2><h3 id="channel">Channel</h3><p>可以把 Channel 看作是传入(入站)或者传出(出站)数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。</p><h3 id="回调">回调</h3><p>一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。回调在广泛的编程场景中都有应用，而且也是在操作完成后通知相关方最常见的方式之一。</p><h3 id="future">Future</h3><p>Future 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符;它将在未来的某个时刻完成，并提供对其结果的访问。</p><h4 id="channelfuture">ChannelFuture</h4><p>Netty 提供了它自己的实现—— <code>ChannelFuture</code>，用于在执行异步操作的时候使用。
<code>ChannelFuture</code>提供了几种额外的方法，这些方法使得我们能够注册一个或者多个<code>ChannelFutureListener</code>实例。
由<code>ChannelFutureListener</code>提供的通知机制消除了手动检查对应的操作是否完成的必要。
每个 Netty 的出站 I/O 操作都将返回一个<code>ChannelFuture</code>，也就是说，它们都不会阻塞。</p><h3 id="事件和channel-handler">事件和Channel Handler</h3><p>Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。
每个事件都可以被分发给<code>ChannelHandler</code>类中的某个用户实现的方法。</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/4c91d52e72e8cadafa888f8ad24df10f03d5a211.png" alt="screenshot-20211017230453"></p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/6417a8aa22b524e344b2aad88bfd58d8dca62565.png" alt="screenshot-20211017230733"></p><p><code>ChannelPipeline</code>中的每个<code>ChannelHandler</code>将负责把事件转发到链中的下一个<code>ChannelHandler</code>。这些适配器类（及它们的子类）将自动执行这个操作，所以你可以只重写那些你想要特殊处理的方法和事件。</p><p>虽然<code>ChannelInboundHandler</code> 和<code>ChannelOutboundHandlr</code> 都扩展自<code>ChannelHandler</code>，但是Netty 能区分<code>ChannelInboundHandler</code>实现和<code>ChannelOutboundHandler</code> 实现，并确保数据只会在具有相同定向类型的两个<code>ChannelHandler</code> 之间传递。</p><p><code>@Sharable</code>注解Handler，标识一个Handler可以被多个Channel安全地共享。</p><h2 id="发送消息的方式">发送消息的方式</h2><p>在Netty中，有两种发送消息的方式。你可以直接写到Channel中，也可以写到和<code>ChannelHandler</code>相关联的<code>ChannelHandlerContext</code>对象中。前一种方式将会导致消息从<code>ChannelPipeline</code>的尾端开始流动，而后者将导致消息从<code>ChannelPipeline</code>中的下一个<code>ChannelHandler</code>开始流动。</p><h3 id="写入channel">写入Channel</h3><p>通过<code>ChannelHandlerContext</code>获取到Channel的引用。调用Channel上的<code>write()</code>方法将会导致写入事件从尾端到头部地流经<code>ChannelPipeline</code>。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl"><span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">channel</span><span class="o">.</span><span class="na">write</span><span class="o">(...);</span>
</span></span></code></pre></td></tr></table></div></div><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl"><span class="n">ChannelPipeline</span> <span class="n">pipeline</span> <span class="n">ctx</span><span class="o">.</span><span class="na">pipeline</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pipeline</span><span class="o">.</span><span class="na">write</span><span class="o">(...);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id="写入channelhandlercontext">写入ChannelHandlerContext</h3><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="o">...;</span>
</span></span><span class="line"><span class="cl"><span class="n">ctx</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">Unpooled</span><span class="o">.</span><span class="na">copiedBuffer</span><span class="o">(</span><span class="s">&#34;Netty in Action&#34;</span><span class="o">,</span> <span class="n">CharsetUtil</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
</span></span></code></pre></td></tr></table></div></div><h2 id="使用nio">使用NIO</h2><p>使用epoll 替代NIO，只需要将<code>NioEventLoopGroup</code>替换为<code>EpollEventLoopGroup</code> ，并且将<code>NioServerSocketChannel.class</code>替换为<code>EpollServerSocketChannel.class</code>即可。</p><p>Netty所提供的传输：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/148b5d59878ea0489d3e07d4347e60d9b890d5bd.png" alt="screenshot-20211017232908"></p><p>应用程序的最佳传输：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/184a6691a5e2ab9839d5670ce45a97ab07e0a0dc.png" alt="screenshot-20211017233024"></p><h2 id="派生缓冲区">派生缓冲区</h2><p>派生缓冲区为ByteBuf 提供了以专门的方式来呈现其内容的视图。</p><ul><li><code>duplicate()</code></li><li><code>slice()</code></li><li><code>slice(int, int)</code></li><li><code>Unpooled.unmodifiableBuffer()</code></li><li><code>order(ByteOrder)</code></li><li><code>readSlice(int)</code></li></ul><h2 id="channel生命周期">channel生命周期</h2><ul><li><code>ChannelUnregistered</code>：Channel 已经被创建，但还未注册到<code>EventLoop</code></li><li><code>ChannelRegistered</code>：Channel 已经被注册到了<code>EventLoop</code></li><li><code>ChannelActive</code>：Channel 处于活动状态（已经连接到它的远程节点）。它现在可以接收和发送数据了</li><li><code>ChannelInactive</code>：Channel 没有连接到远程节点</li></ul><p>Channel的状态模型：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/7c308a8321fe07d4528f53adfafb390e3dfe4bcb.png" alt="screenshot-20211017233210"></p><h2 id="channelhandler-的生命周期">ChannelHandler 的生命周期</h2><ul><li><code>handlerAdded</code>：当把<code>ChannelHandler</code> 添加到<code>ChannelPipeline</code> 中时被调用</li><li><code>handlerRemoved</code>：当从<code>ChannelPipeline</code> 中移除<code>ChannelHandler</code> 时被调用</li><li><code>exceptionCaught</code>：当处理过程中在<code>ChannelPipeline</code> 中有错误产生时被调用</li></ul><p>Netty 定义了下面两个重要的<code>ChannelHandler</code> 子接口：</p><ul><li><code>ChannelInboundHandler</code>：处理入站数据以及各种状态变化</li><li><code>ChannelOutboundHandler</code>：处理出站数据并且允许拦截所有的操作</li></ul><p>ChannelInboundHandler的方法：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/ae02e1d498c9835332bbe0d558e02388a3edc752.png" alt="screenshot-20211017233409"></p><p>一个更加简单的方式是使用<code>SimpleChannelInboundHandler</code>：
由于<code>SimpleChannelInboundHandler</code> 会自动释放资源，所以你不应该存储指向任何消息的引用供将来使用，因为这些引用都将会失效。</p><h2 id="出站">出站</h2><p>如果一个消息被消费或者丢弃了，并且没有传递给<code>ChannelPipeline</code> 中的下一个
<code>ChannelOutboundHandler</code>，那么用户就有责任调用<code>ReferenceCountUtil.release()</code>。</p><p>如果消息到达了实际的传输层，那么当它被写入时或者<code>Channel</code> 关闭时，都将被自动释放。
不仅要释放资源，还要通知<code>ChannelPromise</code>。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">promise</span><span class="o">.</span><span class="na">setSuccess</span><span class="o">();</span>
</span></span></code></pre></td></tr></table></div></div><p>否则可能会出现<code>ChannelFutureListener</code> 收不到某个消息已经被处理了的通知的情况。</p><p>ChannelOutboundHandler的方法：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/6c01b8de665d6fa78e8fc9624454a1a0d102bd5e.png" alt="screenshot-20211017233533"></p><p>在<code>ChannelPipeline</code> 传播事件时，它会测试<code>ChannelPipeline</code> 中的下一个<code>ChannelHandler</code> 的类型是否和事件的运动方向相匹配。如果不匹配，<code>ChannelPipeline</code> 将跳过该<code>ChannelHandler</code> 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p><p><code>ChannelHandler</code>的用于修改<code>ChannelPipeline</code>的方式：</p><ul><li><code>addFirst</code>、<code>addBefore</code>、<code> addAfter</code>、<code>addLast</code> &mdash;> 将一个ChannelHandler添加到ChannelPipeline中</li><li><code>remove</code>、<code>replace</code></li></ul><p><code>ChannelPipeline</code>的入站操作：<code>fireXXXX</code></p><p><code>ChannelPipeline</code>的出站操作，和<code>ChannelOutboundHandler</code> 基本一致。</p><p><code>ChannelPipeline</code> 保存了与<code>Channel</code> 相关联的<code>ChannelHandler</code>；
<code>ChannelPipeline</code> 可以根据需要，通过添加或者删除<code>ChannelHandler</code> 来动态地修改；
<code>ChannelPipeline</code> 有着丰富的API 用以被调用，以响应入站和出站事件。</p><p><code>ChannelHandlerContext</code> 和<code>ChannelHandler</code> 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；
相对于其他类的同名方法，<code>ChannelHandlerContext</code>的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</p><p>Channel、ChannelPipeline、ChannelHandler以及ChannelHandlerContext之间的关系：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/db61985fbed74b2b13dfbbf6dce272d166be4595.png" alt="screenshot-20211017233654"></p><p>要想调用从某个特定的<code>ChannelHandler</code> 开始的处理过程，必须获取到在该<code>ChannelHandler</code> 之前的<code>ChannelHandler</code> 所关联的<code>ChannelHandlerContext</code>。这个<code>ChannelHandlerContext</code> 将调用和它所关联的<code>ChannelHandler</code> 之后的<code>ChannelHandler</code>。</p><h2 id="异常处理">异常处理</h2><p>处理入站异常：<code>exceptionCaught</code></p><p>处理出站异常</p><p>每个出站操作都将返回一个<code>ChannelFuture</code>。注册到<code>ChannelFuture</code> 的<code>ChannelFutureListener</code> 将在操作完成时被通知该操作是成功了还是出错了。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ChannelFuture</span> <span class="n">future</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">future</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelFutureListener</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationComplete</span><span class="o">(</span><span class="n">ChannelFuture</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span></code></pre></td></tr></table></div></div><p>几乎所有的<code>ChannelOutboundHandler</code> 上的方法都会传入一个<code>ChannelPromise</code>的实例。
作为<code>ChannelFuture</code> 的子类，<code>ChannelPromise</code> 也可以被分配用于异步通知的监听器。但是，<code>ChannelPromise</code> 还具有提供立即通知的可写方法：</p><ul><li><code>ChannelPromise setSuccess();</code></li><li><code>ChannelPromise setFailure(Throwable cause);</code></li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OutboundExceptionHandler</span> <span class="kd">extends</span> <span class="n">ChannelOutboundHandlerAdapter</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">Object</span> <span class="n">msg</span><span class="o">,</span> <span class="n">ChannelPromise</span> <span class="n">promise</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">promise</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelFutureListener</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationComplete</span><span class="o">(</span><span class="n">ChannelFuture</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//...
</span></span></span></code></pre></td></tr></table></div></div><h2 id="eventloop">EventLoop</h2><p>一个<code>EventLoop</code> 将由一个永远都不会改变的<code>Thread</code> 驱动。
提供了一个更加简单的执行体系架构，并且消除了在多个<code>ChannelHandler</code> 中进行同步的需要</p><h3 id="任务调度">任务调度</h3><p>稍后执行：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ScheduledFuture</span><span class="o">&lt;?&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="na">eventLoop</span><span class="o">().</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;60 seconds later&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">},</span> <span class="n">60</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</span></span></code></pre></td></tr></table></div></div><p>用于非阻塞传输（如NIO和AIO）的<code>EventLoop</code>分配方式：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/667bc0ce024511ae3cbb7544096a06c79454abf4.png" alt="screenshot-20211017234012"></p><p>上图显示了一个<code>EventLoopGroup</code>，它具有3 个固定大小的<code>EventLoop</code>（每个<code>EventLoop</code>都由一个<code>Thread</code> 支撑）。在创建<code>EventLoopGroup</code> 时就直接分配了<code>EventLoop</code>（以及支撑它们的<code>Thread</code>），以确保在需要时它们是可用的。</p><p><code>EventLoopGroup</code> 负责为每个新创建的<code>Channel</code> 分配一个<code>EventLoo</code>p。在当前实现中，使用顺序循环的方式进行分配以获取一个均衡的分布。</p><p>一旦一个<code>Channel</code> 被分配给一个<code>EventLoop</code>，它将在它的整个生命周期中都使用这个<code>EventLoop</code>（以及相关联的<code>Thread</code>）</p><h2 id="bootstrap">Bootstrap</h2><p><code>Bootstrap</code> 类被用于客户端或者使用了无连接协议的应用程序中。</p><p>对于NIO 以及OIO 传输两者来说，都有相关的<code>EventLoopGroup</code> 和<code>Channel</code> 实现。不能混用具有不同前缀的组件，否则将会导致<code>IllegalStateException</code></p><p><code>ServerBootstrap</code>和<code>ServerChannel</code>：</p><p><img src="https://raw.githubusercontent.com/straicat/blog-assets/master/img/8md9t/e24130b8b324c5bf304c8ed1ba6c4d39f4f70690.png" alt="screenshot-20211017234159"></p><h2 id="channel实现">Channel实现</h2><p><code>ChannelInitializer</code> 定义了下面的方法：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">protect</span> <span class="n">ed</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="n">C</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
</span></span></code></pre></td></tr></table></div></div><p>这个方法提供了一种将多个<code>ChannelHandler</code> 添加到一个<code>ChannelPipeline</code> 中的简便
方法。</p><p>Netty提供了各种<code>DatagramChannel</code>的实现，不再调用<code>connect</code>方法，而是只调用<code>bind</code>方法。</p><p><code>EmbeddedChannel</code>:用于测试<code>ChannelHandler</code>。这个传输是一种特殊的Channel 实现。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/">Java</a>
<a href="/tags/netty/">Netty</a></div><nav class="post-nav"><a class="prev" href="/p/8mkvr/"><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">基于Netty实现简单的Redis客户端</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class="next" href="/p/8mc4b/"><span class="next-text nav-default">简单重置JetBrains试用</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src="https://utteranc.es/client.js" repo="straicat/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:1121672253@qq.com" class="iconfont icon-email" title="email"></a>
<a href="https://github.com/straicat" class="iconfont icon-github" title="github"></a>
<a href="https://www.zhihu.com/people/wjmr" class="iconfont icon-zhihu" title="zhihu"></a>
<a href="https://space.bilibili.com/4583328" class="iconfont icon-bilibili" title="bilibili"></a>
<a href="https://muranxuan.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动</span>
<span class="division">|</span>
<span class="theme-info">主题 -
<a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a></span>
<span class="copyright-year">&copy;
2015 -
2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>木然猫猫</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js" type="application/javascript"></script>
<script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/slideout/1.0.1/slideout.min.js" type="application/javascript"></script>
<script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js" type="application/javascript"></script>
<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
<script src="/js/custom.js"></script></body></html>